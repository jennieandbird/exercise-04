---
title: "wordle.Rmd"
author: "Sydney Jansen and Jennie DeVore"
date: "2024-02-12"
output: html_document
---

```{r Step_1}

library(tidyverse)
library(dplyr)

# use links to a public repo because it liked the links to end in .txt instead of the token when the repo was set to private
file1 <- "https://raw.githubusercontent.com/jennieandbird/exercise-04/main/collins-scrabble-words-2019.txt"
file2 <- "https://raw.githubusercontent.com/jennieandbird/exercise-04/main/google-10000-english-usa-no-swears.txt"

# Create your own custom function called load_dictionary() that takes a single argument, “filename”, that can be used to read in either of the two data files you downloaded.

#Step 1: Create Function
load_dictionary <- function(filename) {
  v1 <- read_csv(filename)}

# Once you have created your function, use that function to create two variables, solution_list and valid_list, that, respectively contain vectors of possible solution words and valid words to guess. That is, you should be able to run the following to create these two vectors

valid_list <- load_dictionary(file1)
solution_list <- load_dictionary(file2)

# Running str(valid_list) should return… chr [1:279496] "AA" "AAH" "AAHED" "AAHING"...
# Running str(solution_list) should return… chr [1:8336] "THE" "OF" "AND" "TO"...

str(valid_list)
# running this does say... chr [1:279496] "AA" "AAH" "AAHED" "AAHING" ..." ...so that's good!
str(solution_list)
# and this one says... chr [1:9884] "THE" "OF" "AND" "TO" ... ... also good!

# Step 1 complete! (I think!)

```
```{r Step_2}
# Winnow your variable solution_list to only include words that are included in valid_list. There are multiple ways that you could do this, but the set operation function, intersection() is an easy way. Use R help to look at the documentation for the intersection() function to see if you can get that to work. 

solution_list <- intersect(valid_list, solution_list)

# How many words are in your updated solution_list vector?

print(solution_list)

# solution_list updated to include 8336 words, down from 9884 words.

```
``` {r Step_3}
# Write a custom function called pick_solution() that [1] removes all words from solution_list that are not 5 letters in length, [2] then randomly chooses a single word from those that remain, and [3] then splits that word into a vector of single-character elements. You should be able to pass your solution_list vector as the argument to the function.
pick_solution <- function(df) {
  df_filtered <- df |> 
    filter(nchar(words) == 5)
  return(df_filtered)
}

filtered_solutions <- pick_solution(solution_list)


# HINT: For [1], you will want to subset the solution_list vector according to some criterion of word length. For [2], you may find the sample() function useful (use R help to look up documentation on that function). For [3], you may want to look at the functions strsplit() from {base} R or str_split() from the {stringr} package (part of {tidyverse}). Pay attention to the data structure that those functions return, because you will need to carefully reference one of the elements that is returned in order to wind up with a vector.

# As a bonus, you might include a second argument for your pick_solution() function called “word_length” that makes your function flexible enough to select a solution word that is something other than 5 characters long.

# Once your function works, run it and assign the result to a variable called solution.
# solution <- pick_solution(solution_list)

```

```
``` {r Step_4}
#Now, to tackle the bulk of the problem, create two more functions. The first should be called play_wordle() and it should take three arguments: [1] the answer to the puzzle (the value of your solution variable), [2] a list of valid guesses (the contents of your valid_list variable), and [3] a value for “number of guesses”, which you should set to the original Wordle game default of 6.#


#HINT: Here is possible skeleton code for that function.

play_wordle <- function(solution, valid_list, num_guesses=6){
      <function code here>
    }
Think carefully about what the play_wordle() function needs to do. It should:

At the onset, tell the player the rules of the game, e.g., “You have … chances to guess a word of length …”

Display what letters the player has not yet guessed (at the onset, this would be all 26 letters of the alphabet), e.g., “Letters left: …”

HINT: There is a built-in dataset in R called LETTERS, which contains the 26 capital letters in the English alphabet and another, letters, that contains all the lowercase letters. You will probably want to use either the toupper() or tolower() functions to ensure that you are always working with the same formatted letters in words and guesses.

# using the LETTERS built-in vector
LETTERS

##  [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S"
## [20] "T" "U" "V" "W" "X" "Y" "Z"
# using the `toupper()` function
toupper("change my case")

## [1] "CHANGE MY CASE"
Prompt the player for a guess, e.g., “Enter guess number …”, read in their guess, and check that their guess is valid (i.e., that it contains the correct number of letters and is a word included in the “valid” word list).
HINT: The readline() function, which can take a character string as an argument, will provide a “prompt” entering a line of numeric or character data. Hitting <enter> or <return> signals the end of the line.

guess <- readline("Enter some data here, then press <enter>: ")
Compare the guess to the solution word and generate the necessary feedback, e.g., * for in the word and in the correct position, + for in the word but in the wrong position, and - for not in the word. For this step, try writing a separate “helper” function, evaluate_guess(), called from within play_wordle(). This function should take, as arguments, the player’s guess and the value of the solution variable. This is probably the trickiest part of the problem to program, and there are lots of approaches you might take to evaluating guesses. After you work on this for a while, I can share one solution.

Update the list of letters not yet guessed.

HINT: Again, consider using set operations to update the list of letters not yet guessed. setdiff() is a function that returns the difference between two vectors.

Check if the puzzle was solved. If so, the function should indicate that the player WON the game and print out their guess and feedback history. If not, the function should prompt the player for another guess, unless they have already hit the maximum number of guesses allowed.

If all guesses are exhausted, the function should indicate that the player LOST the game and, again, print out their guess and feedback history.

```

```{r extra_code}
# putting this extra code here in case we need it:

w1 <- read_csv(w11)
  df <- w1 |>
  filter(nchar(words) == 5)

w2 <- read_csv(w22)
  df <- w2 |>
  filter(nchar(words) == 5)


joined_words <- inner_join(w1, w2, by = c("words"))


 load_dictionary <- function(filename) {
  filepath <- paste0(filename, ".txt")
  
  # Check if the file exists
  if (!file.exists(filepath)) {
    stop("File does not exist: ", filepath)
  }
   data <- read.csv(filepath, header = TRUE, sep = ",", stringsAsFactors = FALSE)
     # Assuming the column containing words is named 'word'
  # Filter to include only 5-letter words
  filtered_data <- data[nchar(data$word) == 5, ]
  
  return(filtered_data)
}
##

five_letter_words <- words[grepl("\\b\\w{5}\\b", words)]
```