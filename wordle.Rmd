---
title: "wordle.Rmd"
author: "Sydney Jansen and Jennie DeVore"
date: "2024-02-12"
output: html_document
---

```{r Step_1}

library(tidyverse)
library(dplyr)

# use links to a public repo because it liked the links to end in .txt instead of the token when the repo was set to private
file1 <- "https://raw.githubusercontent.com/jennieandbird/exercise-04/main/collins-scrabble-words-2019.txt"
file2 <- "https://raw.githubusercontent.com/jennieandbird/exercise-04/main/google-10000-english-usa-no-swears.txt"

# Create your own custom function called load_dictionary() that takes a single argument, “filename”, that can be used to read in either of the two data files you downloaded.

#Step 1: Create Function
load_dictionary <- function(filename) {
  v1 <- read_csv(filename)}

# Once you have created your function, use that function to create two variables, solution_list and valid_list, that, respectively contain vectors of possible solution words and valid words to guess. That is, you should be able to run the following to create these two vectors

valid_list <- load_dictionary(file1)
solution_list <- load_dictionary(file2)

# Running str(valid_list) should return… chr [1:279496] "AA" "AAH" "AAHED" "AAHING"...
# Running str(solution_list) should return… chr [1:8336] "THE" "OF" "AND" "TO"...

str(valid_list)
# running this does say... chr [1:279496] "AA" "AAH" "AAHED" "AAHING" ..." ...so that's good!
str(solution_list)
# and this one says... chr [1:9884] "THE" "OF" "AND" "TO" ... ... also good!

# Step 1 complete! (I think!)

```
```{r Step_2}
# Winnow your variable solution_list to only include words that are included in valid_list. There are multiple ways that you could do this, but the set operation function, intersection() is an easy way. Use R help to look at the documentation for the intersection() function to see if you can get that to work. 

solution_list <- intersect(valid_list, solution_list)

# How many words are in your updated solution_list vector?

print(solution_list)

# solution_list updated to include 8336 words, down from 9884 words.

```
``` {r Step_3}
# Write a custom function called pick_solution() that [1] removes all words from solution_list that are not 5 letters in length, [2] then randomly chooses a single word from those that remain, and [3] then splits that word into a vector of single-character elements. You should be able to pass your solution_list vector as the argument to the function.

pick_solution <- function(solution_list){
  # [1] remove all words that are not 5 letters in length
  df <- filter(solution_list, nchar(solution_list$words) == 5)
  # [2] randomly choose a single word
  chooseword <- df[sample(nrow(df), 1), ]
  # [3] split that word into a vector
  str_extract_all(chooseword, boundary("character"))
}

# Once your function works, run it and assign the result to a variable called solution.
# solution <- pick_solution(solution_list)

solution <- pick_solution(solution_list)
# realized this was a list when it should be a vector!
solutionvector <- unlist(solution)

```


``` {r Step_4}
# Now, to tackle the bulk of the problem, create two more functions. The first should be called play_wordle() and it should take three arguments: [1] the answer to the puzzle (the value of your solution variable), [2] a list of valid guesses (the contents of your valid_list variable), and [3] a value for “number of guesses”, which you should set to the original Wordle game default of 6.

play_wordle <- function(solution, valid_list, num_guesses = 6){
  # [1] At the onset, tell the player the rules
  num_guesses <- 6
  print(paste("You have", num_guesses, "chances to guess a 5-letter word."))
  guesses <- 0
  #   Starting out, LETTERS is all of the letters (because the player has not guessed any yet) but will need to update with subtracted letters that were guessed
  letters_remaining <- LETTERS
  # [2] Display what letters the player has not guessed yet
  while (guesses < num_guesses) print(paste(c("Letters remaining: ", letters_remaining), collapse = " ")
  # [3] Prompt the player for a guess, read in their guess, and check if it is valid
  guess <- readline("Try to guess the word!") 
  if(!(guess %in% solution_list)) {print("Word not in list, try another please!")}
  if(nchar(guess) != 5) {print("Word needs to be 5 letters long.")}
  # make sure it's in all caps
  guess <- toupper(guess)
  # make the player's guess into a vector of single-character letters
  guess1 <- str_extract_all(guess, boundary("character"))
  # make it a vector instead of a list:
  guess1vector <- unlist(guess1)
  # [4] (See "evaluate_guess" function below)
  # [5] Update the list of letters not yet guessed
  paste(setdiff(guess1vector,LETTERS))
  # [6] Check if the puzzle was solved; if so, print out guess and feedback history, if not, prompt for another guess
  # [7] If all guesses are exhausted, indicate the player lost and print out guess and feedback history
    }

  
evaluate_guess <- function(guess1, solution){
  # [4] Compare the guess to the solution word and generate feedback with a separate helper function  
  # compare player's guess with the solution
  setdiff(paste(guess1vector), paste(solutionvector))
  lettersinword <- intersect(guess1vector, solutionvector)
  # this part needs to be a loop but I haven't figured it out yet!
  for (i in 1:5 { if (guess1[i] == solution[i])}) 
}

```

```{r extra_code}
# putting this extra code here in case we need it:

```